---
phase: 03-keystroke-injection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [Cargo.toml, src/permission.rs, src/injection.rs]
autonomous: true

must_haves:
  truths:
    - "KeystrokeInjector can type plain text into focused application"
    - "KeystrokeInjector releases modifier keys before typing"
    - "KeystrokeInjector supports configurable keystroke delay"
    - "Macro sequences with special keys {Enter}, {Tab}, etc. are parsed correctly"
    - "macOS accessibility permission is checked before injection"
  artifacts:
    - path: "src/permission.rs"
      provides: "Accessibility permission checking"
      exports: ["check_accessibility_permission"]
    - path: "src/injection.rs"
      provides: "Keystroke injection and macro parsing"
      exports: ["KeystrokeInjector", "MacroSegment", "parse_macro_sequence"]
    - path: "Cargo.toml"
      provides: "enigo and macos-accessibility-client dependencies"
      contains: "enigo"
  key_links:
    - from: "src/injection.rs"
      to: "enigo"
      via: "Enigo::new and keyboard methods"
      pattern: "enigo::(Enigo|Keyboard)"
    - from: "src/permission.rs"
      to: "macos-accessibility-client"
      via: "application_is_trusted_with_prompt"
      pattern: "application_is_trusted_with_prompt"
---

<objective>
Create the core keystroke injection infrastructure including permission checking, text injection with modifier release, configurable delay, and macro sequence parsing.

Purpose: Enable KeyBlast to type text into any focused application safely (releasing hotkey modifiers first) and support special keys in sequences.
Output: permission.rs module for macOS accessibility, injection.rs module with KeystrokeInjector and macro parsing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/3-keystroke-injection/03-RESEARCH.md

Reference files:
@src/main.rs (current event loop structure)
@src/hotkey.rs (HotkeyManager pattern)
@Cargo.toml (current dependencies)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies and create permission module</name>
  <files>Cargo.toml, src/permission.rs</files>
  <action>
Add enigo and macos-accessibility-client to Cargo.toml:

```toml
[dependencies]
enigo = "0.6"

[target.'cfg(target_os = "macos")'.dependencies]
macos-accessibility-client = "0.0.1"
```

Create src/permission.rs with:
- `check_accessibility_permission()` function that returns bool
- On macOS: Use `application_is_trusted_with_prompt()` from macos-accessibility-client
- On non-macOS: Return true (Windows/Linux don't need special permission for input simulation)
- Add documentation explaining macOS Accessibility requirements

Use `#[cfg(target_os = "macos")]` and `#[cfg(not(target_os = "macos"))]` conditional compilation.
  </action>
  <verify>
`cargo check` passes with new dependencies. No compilation errors.
  </verify>
  <done>
permission.rs exists with check_accessibility_permission() that compiles cross-platform.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create KeystrokeInjector with modifier release and delay</name>
  <files>src/injection.rs</files>
  <action>
Create src/injection.rs with KeystrokeInjector struct:

1. **KeystrokeInjector struct** holding an Enigo instance:
   - `new()` constructor with Settings that:
     - Sets `open_prompt_to_get_permissions: false` on macOS (we handle prompts ourselves)
     - Sets `independent_of_keyboard_state: true` on macOS
     - Sets `release_keys_when_dropped: true`
   - Returns Result with descriptive error

2. **release_modifiers()** method:
   - Release Control, Shift, Alt, Meta keys using `enigo.key(Key::X, Direction::Release)`
   - This is CRITICAL: hotkey triggers while modifiers are held, must release before typing

3. **type_text_with_delay()** method:
   - Takes text: &str and delay_ms: u64
   - Calls release_modifiers() first
   - Waits 10ms to ensure modifiers are released
   - If delay_ms == 0: Use bulk `enigo.text(text)` for speed
   - If delay_ms > 0: Loop through chars, call `enigo.text(&c.to_string())`, sleep delay_ms between each
   - Return Result with error info

Use these imports:
```rust
use enigo::{Enigo, Keyboard, Key, Direction, Settings};
use std::time::Duration;
use std::thread;
```
  </action>
  <verify>
`cargo check` passes. KeystrokeInjector compiles with all methods.
  </verify>
  <done>
KeystrokeInjector can be instantiated, releases modifiers, and types text with configurable delay.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add macro sequence parsing for special keys</name>
  <files>src/injection.rs</files>
  <action>
Extend src/injection.rs with macro sequence parsing:

1. **MacroSegment enum**:
   ```rust
   pub enum MacroSegment {
       Text(String),
       SpecialKey(Key),
   }
   ```

2. **parse_macro_sequence()** function:
   - Takes input: &str, returns Vec<MacroSegment>
   - Parse `{KeyName}` escape sequences for special keys
   - Accumulate plain text between escapes
   - Support these keys (case-insensitive):
     - enter, return -> Key::Return
     - tab -> Key::Tab
     - escape, esc -> Key::Escape
     - backspace -> Key::Backspace
     - delete, del -> Key::Delete
     - up -> Key::UpArrow
     - down -> Key::DownArrow
     - left -> Key::LeftArrow
     - right -> Key::RightArrow
     - home -> Key::Home
     - end -> Key::End
     - pageup, pgup -> Key::PageUp
     - pagedown, pgdn -> Key::PageDown
     - space -> Key::Space
   - Unknown keys in braces are passed as literal text (don't crash)

3. **execute_sequence()** method on KeystrokeInjector:
   - Takes segments: &[MacroSegment] and delay_ms: u64
   - Calls release_modifiers() first, waits 10ms
   - For Text segments: type text (bulk or char-by-char based on delay)
   - For SpecialKey segments: `enigo.key(key, Direction::Click)`, then delay if > 0
   - Return Result

4. **Helper function** special_key_from_name(name: &str) -> Option<Key>:
   - Maps lowercase key names to enigo Key variants
  </action>
  <verify>
`cargo check` passes.
Verify parsing logic manually: "Hello{Enter}World" should produce [Text("Hello"), SpecialKey(Return), Text("World")].
  </verify>
  <done>
parse_macro_sequence() correctly parses escape sequences, execute_sequence() types mixed text and special keys.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `cargo check` passes with no errors
2. `cargo build --release` succeeds
3. src/permission.rs exports check_accessibility_permission()
4. src/injection.rs exports KeystrokeInjector, MacroSegment, parse_macro_sequence()
5. Code handles both macOS and non-macOS compilation targets
</verification>

<success_criteria>
- KeystrokeInjector can be created and releases modifiers before typing
- type_text_with_delay() handles both instant (0ms) and slow typing
- parse_macro_sequence() correctly identifies special key escapes
- execute_sequence() types text and presses special keys with configurable delay
- macOS accessibility permission check is available (integration comes in Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/3-keystroke-injection/03-01-SUMMARY.md`
</output>
