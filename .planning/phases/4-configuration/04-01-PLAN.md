---
phase: 04-configuration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [Cargo.toml, src/config.rs]
autonomous: true

must_haves:
  truths:
    - "Config module can serialize macros to TOML string"
    - "Config module can deserialize TOML string to macros"
    - "Config module knows where to store config file per platform"
  artifacts:
    - path: "src/config.rs"
      provides: "Config data model and file operations"
      exports: ["Config", "MacroDefinition", "load_config", "save_config", "config_path"]
    - path: "Cargo.toml"
      provides: "serde and toml dependencies"
      contains: "serde"
  key_links:
    - from: "src/config.rs"
      to: "serde/toml"
      via: "derive macros and toml crate"
      pattern: "#\\[derive.*Serialize.*Deserialize"
---

<objective>
Create the configuration data model and file handling for persistent macro storage.

Purpose: Enable macros to be defined in a human-readable TOML file that survives app restarts.
Output: A config.rs module with data structures and load/save functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/hotkey.rs (HotkeyManager, HotKey structure for reference)
@src/injection.rs (MacroSegment, parse_macro_sequence for reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add serde and toml dependencies</name>
  <files>Cargo.toml</files>
  <action>
Add serde and toml dependencies to Cargo.toml:
- serde = { version = "1.0", features = ["derive"] }
- toml = "0.8"

These are the standard Rust ecosystem choices for config file handling.
  </action>
  <verify>`cargo check` succeeds with new dependencies</verify>
  <done>Cargo.toml includes serde with derive feature and toml crate</done>
</task>

<task type="auto">
  <name>Task 2: Create config module with data model and file operations</name>
  <files>src/config.rs</files>
  <action>
Create src/config.rs with:

1. **Data structures** (derive Serialize, Deserialize, Clone, Debug):
   - `MacroDefinition`: name (String), hotkey (String like "ctrl+shift+k"), text (String with {Enter} etc), delay_ms (u64, default 0)
   - `Config`: version (u32, default 1), macros (Vec<MacroDefinition>)

2. **Config path function** `config_path() -> PathBuf`:
   - macOS: ~/Library/Application Support/keyblast/config.toml
   - Windows: %APPDATA%/keyblast/config.toml
   - Linux: ~/.config/keyblast/config.toml
   - Use dirs crate or std::env for platform detection

3. **Load function** `load_config() -> Result<Config, ConfigError>`:
   - If file doesn't exist, return default Config with empty macros vec
   - If file exists, read and parse TOML
   - Return ConfigError for parse failures

4. **Save function** `save_config(config: &Config) -> Result<(), ConfigError>`:
   - Create parent directories if needed
   - Serialize to pretty TOML (toml::to_string_pretty)
   - Write atomically (write to temp, rename)

5. **Default config** `Config::default()`:
   - Returns Config with version=1, empty macros vec

6. **Hotkey parsing helper** (for Phase 4 Plan 02):
   - `parse_hotkey_string(s: &str) -> Option<HotKey>`: Parse "ctrl+shift+k" into global_hotkey::HotKey
   - Handle modifiers: ctrl, shift, alt, meta/cmd/super
   - Handle keys: a-z, 0-9, f1-f12

Add `mod config;` to main.rs.

Note: Use the dirs crate for cross-platform config paths. Add `dirs = "5.0"` to Cargo.toml.
  </action>
  <verify>
`cargo test` passes (add unit tests for parse_hotkey_string and round-trip serialization).
Create a test that serializes a Config with one macro, deserializes it, and verifies equality.
  </verify>
  <done>
- src/config.rs exists with Config, MacroDefinition, load_config, save_config, config_path, parse_hotkey_string
- Unit tests verify serialization round-trip and hotkey string parsing
- `cargo check` and `cargo test` pass
  </done>
</task>

</tasks>

<verification>
- `cargo check` passes
- `cargo test` passes (config module tests)
- Config module exports: Config, MacroDefinition, load_config, save_config, config_path, parse_hotkey_string
</verification>

<success_criteria>
- Config data model defined with serde derives
- TOML serialization/deserialization works (verified by tests)
- Platform-specific config path determined
- load_config returns default when file missing
- save_config creates directories and writes atomically
- parse_hotkey_string converts "ctrl+shift+k" to HotKey
</success_criteria>

<output>
After completion, create `.planning/phases/4-configuration/04-01-SUMMARY.md`
</output>
