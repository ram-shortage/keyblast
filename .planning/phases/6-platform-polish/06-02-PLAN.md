---
phase: 06-platform-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/permission.rs
  - src/tray.rs
  - src/main.rs
  - assets/icon-flash.png
autonomous: true

must_haves:
  truths:
    - "macOS user sees clear guidance when Accessibility permission is not granted"
    - "User sees tray icon flash when macro triggers successfully"
    - "Icon flash does not block the event loop"
  artifacts:
    - path: "src/permission.rs"
      provides: "Enhanced permission check with user guidance"
      contains: "System Settings"
    - path: "assets/icon-flash.png"
      provides: "Flash variant of tray icon"
    - path: "src/tray.rs"
      provides: "Icon loading for both normal and flash variants"
      exports: ["load_icon", "load_flash_icon"]
  key_links:
    - from: "src/main.rs"
      to: "tray flash mechanism"
      via: "flash_remaining counter in about_to_wait"
      pattern: "flash_remaining"
    - from: "src/main.rs"
      to: "permission guidance"
      via: "startup check"
      pattern: "check_accessibility_permission"
---

<objective>
Enhance Accessibility permission UX and add tray icon flash feedback (PLAT-04, TRAY-03).

Purpose: Guide macOS users through the Accessibility permission grant process with clear instructions, and provide visual feedback when macros trigger so users know the action worked.

Output: Enhanced permission module with detailed guidance, flash icon asset, and icon flashing mechanism in main event loop.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/6-platform-polish/06-RESEARCH.md
@src/permission.rs
@src/tray.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance Accessibility permission guidance (macOS)</name>
  <files>src/permission.rs</files>
  <action>
Enhance the macOS permission check to provide detailed user guidance when permission is not granted.

Update `src/permission.rs`:

```rust
/// Check if the application has accessibility permission to inject keystrokes.
///
/// On macOS, this will prompt the user to grant permission if not already granted,
/// and print detailed guidance if permission is denied.
/// On other platforms, this always returns `true`.
///
/// # Returns
///
/// `true` if the application has permission (or no permission is needed),
/// `false` if permission was denied or not yet granted on macOS.
#[cfg(target_os = "macos")]
pub fn check_accessibility_permission() -> bool {
    use macos_accessibility_client::accessibility::application_is_trusted_with_prompt;

    let trusted = application_is_trusted_with_prompt();

    if !trusted {
        print_accessibility_guidance();
    }

    trusted
}

#[cfg(target_os = "macos")]
fn print_accessibility_guidance() {
    eprintln!();
    eprintln!("╔══════════════════════════════════════════════════════════════╗");
    eprintln!("║         KeyBlast Accessibility Permission Required           ║");
    eprintln!("╚══════════════════════════════════════════════════════════════╝");
    eprintln!();
    eprintln!("KeyBlast needs Accessibility permission to inject keystrokes.");
    eprintln!("Without this permission, macros will not work.");
    eprintln!();
    eprintln!("To grant permission:");
    eprintln!();
    eprintln!("  1. Open System Settings (or System Preferences on older macOS)");
    eprintln!("  2. Go to: Privacy & Security → Accessibility");
    eprintln!("  3. Click the lock icon to make changes (enter your password)");
    eprintln!("  4. Click the '+' button");
    eprintln!("  5. Navigate to KeyBlast and add it");
    eprintln!("  6. Make sure the checkbox next to KeyBlast is checked");
    eprintln!("  7. Restart KeyBlast");
    eprintln!();
    eprintln!("TIP: The system permission dialog may have appeared behind other windows.");
    eprintln!("     Check your other windows or look for a notification.");
    eprintln!();
    eprintln!("KeyBlast will continue running but macros will not work until");
    eprintln!("permission is granted and the app is restarted.");
    eprintln!();
}

#[cfg(not(target_os = "macos"))]
pub fn check_accessibility_permission() -> bool {
    // Windows and Linux don't need special permissions for input simulation
    true
}
```

This provides:
- Clear visual header
- Step-by-step instructions
- Tip about system dialog potentially being behind windows
- Clear statement about what happens next (app continues but macros won't work)
  </action>
  <verify>
    `cargo check` compiles.
    On macOS without permission: Run app and see detailed guidance in console.
  </verify>
  <done>macOS permission check prints detailed guidance when permission is not granted.</done>
</task>

<task type="auto">
  <name>Task 2: Create flash icon and implement tray flash feedback</name>
  <files>assets/icon-flash.png, src/tray.rs, src/main.rs</files>
  <action>
1. Create a flash variant of the icon (`assets/icon-flash.png`):
   - Use ImageMagick or similar to create a brighter/inverted version of icon.png
   - Command: `convert assets/icon.png -modulate 150,100,100 assets/icon-flash.png`
   - Or manually create a visually distinct version (lighter/brighter)
   - If convert is unavailable, copy icon.png and we'll note it for manual creation

2. Update `src/tray.rs` to load both icons:

```rust
use tray_icon::Icon;

/// Load the normal application icon.
pub fn load_icon() -> Icon {
    load_icon_from_bytes(include_bytes!("../assets/icon.png"))
}

/// Load the flash variant icon for visual feedback.
pub fn load_flash_icon() -> Icon {
    // Use the same icon if flash variant doesn't exist yet
    // This allows the code to compile; the visual difference
    // will be subtle but the mechanism works
    load_icon_from_bytes(include_bytes!("../assets/icon-flash.png"))
}

fn load_icon_from_bytes(bytes: &[u8]) -> Icon {
    let image = image::load_from_memory(bytes)
        .expect("Failed to load icon")
        .into_rgba8();
    let (width, height) = image.dimensions();
    let rgba = image.into_raw();
    Icon::from_rgba(rgba, width, height).expect("Failed to create icon")
}
```

3. Update `src/main.rs` to implement icon flashing:

Add fields to KeyBlastApp:
```rust
/// Flash counter for visual feedback (counts down)
flash_remaining: u8,
/// Normal tray icon
normal_icon: Option<tray_icon::Icon>,
/// Flash tray icon
flash_icon: Option<tray_icon::Icon>,
/// Current flash state (true = showing flash icon)
flash_state: bool,
/// Instant of last flash toggle for timing
last_flash_toggle: Option<std::time::Instant>,
```

Initialize in new():
```rust
flash_remaining: 0,
normal_icon: None,
flash_icon: None,
flash_state: false,
last_flash_toggle: None,
```

In resumed(), after creating tray icon:
```rust
// Store icons for flash feedback
self.normal_icon = Some(tray::load_icon());
self.flash_icon = Some(tray::load_flash_icon());
```

After successful injection in user_event() (after "Injection complete"):
```rust
// Trigger icon flash for visual feedback
self.flash_remaining = 4; // 2 cycles of on/off
self.flash_state = false;
self.last_flash_toggle = Some(std::time::Instant::now());
```

In about_to_wait(), add flash handling (before menu event processing):
```rust
// Handle icon flash animation
if self.flash_remaining > 0 {
    let should_toggle = self.last_flash_toggle
        .map(|t| t.elapsed() >= std::time::Duration::from_millis(100))
        .unwrap_or(true);

    if should_toggle {
        self.flash_state = !self.flash_state;
        self.flash_remaining -= 1;
        self.last_flash_toggle = Some(std::time::Instant::now());

        if let Some(ref tray_icon) = self._tray_icon {
            let icon = if self.flash_state {
                self.flash_icon.clone()
            } else {
                self.normal_icon.clone()
            };
            if let Some(i) = icon {
                let _ = tray_icon.set_icon(Some(i));
            }
        }
    }
}
```

Also update ControlFlow to Poll when flashing for responsive animation:
- At start of about_to_wait: if flash_remaining > 0, we need to keep checking
- The event loop is already ControlFlow::Wait which will work, but flash timing depends on other events
- For smoother flash, check timing in about_to_wait which runs frequently enough
  </action>
  <verify>
    `cargo build --release` succeeds.
    Run app, trigger a macro with Ctrl+Shift+K.
    Observe tray icon briefly flashes (2 quick blinks).
    App remains responsive during flash (can open menu).
  </verify>
  <done>Tray icon flashes when macro triggers, providing visual feedback without blocking UI.</done>
</task>

</tasks>

<verification>
1. `cargo build --release` completes without errors
2. On macOS without permission: detailed guidance printed to console
3. Trigger macro (Ctrl+Shift+K by default): tray icon flashes briefly
4. During flash: app menu is still accessible (not blocked)
5. Flash completes in ~400ms (4 toggles at 100ms each)
</verification>

<success_criteria>
- PLAT-04 complete: macOS user is guided through Accessibility permission
- TRAY-03 complete: Tray icon flashes when macro triggers
- Flash is non-blocking (event loop continues processing)
- Clear, actionable permission guidance printed to console
</success_criteria>

<output>
After completion, create `.planning/phases/6-platform-polish/06-02-SUMMARY.md`
</output>
