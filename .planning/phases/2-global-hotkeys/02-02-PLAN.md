---
phase: 02-global-hotkeys
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/hotkey.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Attempting to register conflicting hotkey returns descriptive error"
    - "HotkeyManager can suggest available hotkey combinations"
    - "Conflict detection distinguishes internal vs external conflicts"
  artifacts:
    - path: "src/hotkey.rs"
      provides: "RegisterResult enum, conflict detection, suggestion generation"
      exports: ["RegisterResult", "HotkeyManager::suggest_available"]
  key_links:
    - from: "HotkeyManager::register"
      to: "RegisterResult"
      via: "Returns typed result instead of raw Error"
      pattern: "RegisterResult::"
    - from: "suggest_available"
      to: "try_register + unregister"
      via: "Tests candidates then releases"
      pattern: "unregister"
---

<objective>
Add conflict detection (HKEY-02) and hotkey suggestions (HKEY-03) to HotkeyManager.

Purpose: Users need to know when a hotkey is unavailable and receive alternatives
Output: HotkeyManager with RegisterResult enum, conflict messages, and suggest_available() method
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/2-global-hotkeys/02-RESEARCH.md
@.planning/phases/2-global-hotkeys/02-01-SUMMARY.md
@src/hotkey.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RegisterResult enum with conflict detection</name>
  <files>src/hotkey.rs</files>
  <action>
1. Create RegisterResult enum:
   ```rust
   pub enum RegisterResult {
       Success,
       ConflictInternal(String),  // Already registered by KeyBlast - include hotkey string
       ConflictExternal(String),  // Taken by OS or another app - include error message
       Error(String),             // Other registration error
   }
   ```

2. Add try_register method to HotkeyManager:
   ```rust
   pub fn try_register(&mut self, hotkey: HotKey, macro_id: String) -> RegisterResult {
       match self.manager.register(hotkey) {
           Ok(()) => {
               self.bindings.insert(hotkey.id(), HotkeyBinding { hotkey, macro_id });
               RegisterResult::Success
           }
           Err(global_hotkey::Error::AlreadyRegistered(hk)) => {
               RegisterResult::ConflictInternal(format!(
                   "Hotkey {} is already registered by KeyBlast",
                   hk.into_string()
               ))
           }
           Err(global_hotkey::Error::FailedToRegister(msg)) => {
               RegisterResult::ConflictExternal(format!(
                   "Hotkey unavailable (may be used by system or another app): {}",
                   msg
               ))
           }
           Err(e) => RegisterResult::Error(format!("Registration error: {}", e)),
       }
   }
   ```

3. Keep original register() method but have it call try_register internally and convert to Result

4. Add unregister method:
   ```rust
   pub fn unregister(&mut self, hotkey: &HotKey) -> Result<(), String> {
       self.manager.unregister(*hotkey)
           .map_err(|e| format!("Failed to unregister: {}", e))?;
       self.bindings.remove(&hotkey.id());
       Ok(())
   }
   ```
  </action>
  <verify>cargo check passes, RegisterResult enum exists</verify>
  <done>try_register returns RegisterResult with conflict info, unregister implemented</done>
</task>

<task type="auto">
  <name>Task 2: Implement hotkey suggestion generation</name>
  <files>src/hotkey.rs</files>
  <action>
1. Define candidate hotkeys (Tier 1 - very likely available):
   ```rust
   fn candidate_hotkeys() -> Vec<HotKey> {
       use global_hotkey::hotkey::{Code, Modifiers};

       let ctrl_shift = Some(Modifiers::CONTROL | Modifiers::SHIFT);
       let ctrl_alt = Some(Modifiers::CONTROL | Modifiers::ALT);

       vec![
           // Ctrl+Shift+<letter> - rarely conflicts
           HotKey::new(ctrl_shift, Code::KeyK),
           HotKey::new(ctrl_shift, Code::KeyM),
           HotKey::new(ctrl_shift, Code::KeyJ),
           HotKey::new(ctrl_shift, Code::KeyL),
           HotKey::new(ctrl_shift, Code::KeyU),
           HotKey::new(ctrl_shift, Code::KeyI),
           HotKey::new(ctrl_shift, Code::KeyO),
           HotKey::new(ctrl_shift, Code::KeyP),
           // Ctrl+Alt+<letter> - rarely conflicts
           HotKey::new(ctrl_alt, Code::KeyK),
           HotKey::new(ctrl_alt, Code::KeyM),
           HotKey::new(ctrl_alt, Code::KeyJ),
           HotKey::new(ctrl_alt, Code::KeyL),
           // Ctrl+Shift+<number>
           HotKey::new(ctrl_shift, Code::Digit1),
           HotKey::new(ctrl_shift, Code::Digit2),
           HotKey::new(ctrl_shift, Code::Digit3),
           HotKey::new(ctrl_shift, Code::Digit4),
       ]
   }
   ```

2. Add suggest_available method to HotkeyManager:
   ```rust
   /// Returns up to `count` available hotkey combinations.
   /// Tests each candidate by registering then immediately unregistering.
   pub fn suggest_available(&self, count: usize) -> Vec<HotKey> {
       let mut suggestions = Vec::new();

       for candidate in candidate_hotkeys() {
           // Skip if already registered by this app
           if self.bindings.contains_key(&candidate.id()) {
               continue;
           }

           // Try to register - if it succeeds, it's available
           match self.manager.register(candidate) {
               Ok(()) => {
                   // Available! Unregister immediately
                   let _ = self.manager.unregister(candidate);
                   suggestions.push(candidate);
                   if suggestions.len() >= count {
                       break;
                   }
               }
               Err(_) => {
                   // Not available, try next
                   continue;
               }
           }
       }

       suggestions
   }
   ```

3. Add helper to format hotkey for display:
   ```rust
   pub fn hotkey_display_string(hotkey: &HotKey) -> String {
       hotkey.into_string()
   }
   ```
  </action>
  <verify>cargo check passes, suggest_available method exists</verify>
  <done>suggest_available() returns available hotkey combinations, candidates defined</done>
</task>

<task type="auto">
  <name>Task 3: Test conflict detection and suggestions in main</name>
  <files>src/main.rs</files>
  <action>
1. After registering the test hotkey in resumed(), test conflict detection:
   ```rust
   // Test conflict detection - try to register same hotkey again
   let duplicate = HotKey::new(
       Some(Modifiers::CONTROL | Modifiers::SHIFT),
       Code::KeyK
   );
   match hotkey_manager.try_register(duplicate, "duplicate".to_string()) {
       RegisterResult::ConflictInternal(msg) => {
           println!("Conflict test passed: {}", msg);
       }
       other => {
           println!("Unexpected result: {:?}", other);
       }
   }
   ```

2. Test suggestion generation:
   ```rust
   // Get 3 available hotkey suggestions
   let suggestions = hotkey_manager.suggest_available(3);
   println!("Available hotkeys:");
   for hk in &suggestions {
       println!("  - {}", hotkey::hotkey_display_string(hk));
   }
   ```

3. Run and verify output shows:
   - "Registered test hotkey: Ctrl+Shift+K"
   - "Conflict test passed: Hotkey ... is already registered by KeyBlast"
   - "Available hotkeys:" followed by 3 suggestions
  </action>
  <verify>cargo run shows conflict detection message and 3 hotkey suggestions on startup</verify>
  <done>Conflict detection works, suggestions generated, all HKEY requirements verified</done>
</task>

</tasks>

<verification>
1. cargo build --release succeeds
2. App startup shows conflict detection working (duplicate registration blocked)
3. App startup shows 3 available hotkey suggestions
4. Suggestions exclude already-registered hotkeys
5. Original test hotkey (Ctrl+Shift+K) still fires correctly
</verification>

<success_criteria>
- RegisterResult enum distinguishes Success, ConflictInternal, ConflictExternal, Error
- try_register() returns descriptive conflict messages (HKEY-02)
- suggest_available(n) returns n available hotkey combinations (HKEY-03)
- Suggestions correctly skip internally-registered hotkeys
- All Phase 2 requirements (HKEY-01, HKEY-02, HKEY-03) satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/2-global-hotkeys/02-02-SUMMARY.md`
</output>
