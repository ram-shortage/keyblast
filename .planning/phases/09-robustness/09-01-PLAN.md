---
phase: 09-robustness
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config.rs
autonomous: true

must_haves:
  truths:
    - "App warns on duplicate macro names at config load"
    - "App warns on duplicate hotkeys at config load"
    - "Importing macros de-dupes within imported file"
    - "Config saves correctly on Windows (overwrites existing)"
  artifacts:
    - path: "src/config.rs"
      provides: "Config validation and Windows save fix"
      contains: "validate_config"
  key_links:
    - from: "src/main.rs"
      to: "src/config.rs::validate_config"
      via: "call after load_config"
      pattern: "validate_config"
---

<objective>
Add config validation for duplicate names/hotkeys, fix import merge de-dupe, and fix Windows config save.

Purpose: Prevent silent config issues and make the app robust across platforms.
Output: Validation functions in config.rs, Windows-compatible save_config.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/config.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add config validation for duplicates</name>
  <files>src/config.rs</files>
  <action>
Add a `ValidationWarning` enum and `validate_config` function to config.rs:

```rust
/// Warnings found during config validation.
#[derive(Debug, Clone)]
pub enum ValidationWarning {
    DuplicateName(String),
    DuplicateHotkey { hotkey: String, names: Vec<String> },
}

/// Validate config and return any warnings.
/// Does NOT modify the config - caller decides what to do with warnings.
pub fn validate_config(config: &Config) -> Vec<ValidationWarning> {
    let mut warnings = Vec::new();

    // Check for duplicate names
    let mut seen_names: HashMap<String, usize> = HashMap::new();
    for macro_def in &config.macros {
        *seen_names.entry(macro_def.name.clone()).or_insert(0) += 1;
    }
    for (name, count) in &seen_names {
        if *count > 1 {
            warnings.push(ValidationWarning::DuplicateName(name.clone()));
        }
    }

    // Check for duplicate hotkeys
    let mut hotkey_to_names: HashMap<String, Vec<String>> = HashMap::new();
    for macro_def in &config.macros {
        let normalized = macro_def.hotkey.to_lowercase();
        hotkey_to_names.entry(normalized).or_default().push(macro_def.name.clone());
    }
    for (hotkey, names) in hotkey_to_names {
        if names.len() > 1 {
            warnings.push(ValidationWarning::DuplicateHotkey { hotkey, names });
        }
    }

    warnings
}
```

Add `use std::collections::HashMap;` at top if not present.

Add Display impl for ValidationWarning for user-friendly messages:
```rust
impl std::fmt::Display for ValidationWarning {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ValidationWarning::DuplicateName(name) => {
                write!(f, "Duplicate macro name: '{}'", name)
            }
            ValidationWarning::DuplicateHotkey { hotkey, names } => {
                write!(f, "Hotkey '{}' used by multiple macros: {}", hotkey, names.join(", "))
            }
        }
    }
}
```
  </action>
  <verify>`cargo build` succeeds, `cargo test` passes</verify>
  <done>validate_config function exists and returns warnings for duplicate names and hotkeys</done>
</task>

<task type="auto">
  <name>Task 2: Fix Windows config save (fs::rename overwrite)</name>
  <files>src/config.rs</files>
  <action>
Update `save_config` function to handle Windows fs::rename behavior. On Windows, fs::rename fails if the destination exists. Fix by removing the destination first:

Replace the atomic write section in save_config:
```rust
// Write atomically: temp file then rename
let temp_path = path.with_extension("toml.tmp");
fs::write(&temp_path, &content)?;

// On Windows, fs::rename fails if destination exists - remove it first
#[cfg(target_os = "windows")]
{
    if path.exists() {
        fs::remove_file(&path)?;
    }
}

fs::rename(&temp_path, &path)?;
```

This preserves atomic write behavior on macOS/Linux while working on Windows.
  </action>
  <verify>`cargo build` succeeds</verify>
  <done>save_config handles Windows overwrite correctly with cfg-gated removal</done>
</task>

<task type="auto">
  <name>Task 3: Fix import de-dupe within imported file</name>
  <files>src/config.rs</files>
  <action>
Add a helper function to de-dupe macros within an imported file and use it in import_macros:

```rust
/// De-duplicate macros by name, keeping the first occurrence.
pub fn dedupe_macros(macros: Vec<MacroDefinition>) -> Vec<MacroDefinition> {
    let mut seen: HashSet<String> = HashSet::new();
    macros.into_iter().filter(|m| seen.insert(m.name.clone())).collect()
}
```

Add `use std::collections::HashSet;` if not present.

Update `import_macros` to de-dupe before returning:
```rust
pub fn import_macros(path: &std::path::Path) -> Result<Vec<MacroDefinition>, ConfigError> {
    let content = fs::read_to_string(path)?;
    let config: Config = toml::from_str(&content)?;
    Ok(dedupe_macros(config.macros))
}
```

Add a unit test:
```rust
#[test]
fn test_import_dedupes_within_file() {
    use tempfile::tempdir;

    let dir = tempdir().unwrap();
    let path = dir.path().join("dupes.toml");

    // Write a file with duplicate names
    let content = r#"
version = 1

[[macros]]
name = "test"
hotkey = "ctrl+1"
text = "first"

[[macros]]
name = "test"
hotkey = "ctrl+2"
text = "second"

[[macros]]
name = "unique"
hotkey = "ctrl+3"
text = "unique"
"#;
    fs::write(&path, content).unwrap();

    let imported = import_macros(&path).unwrap();
    assert_eq!(imported.len(), 2);
    assert_eq!(imported[0].name, "test");
    assert_eq!(imported[0].text, "first"); // First one wins
    assert_eq!(imported[1].name, "unique");
}
```
  </action>
  <verify>`cargo test test_import_dedupes` passes</verify>
  <done>import_macros de-dupes by name, keeping first occurrence</done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds without errors
2. `cargo test` passes all tests including new validation tests
3. Inspect config.rs for:
   - validate_config function exists
   - save_config has Windows cfg-gated removal
   - import_macros calls dedupe_macros
</verification>

<success_criteria>
- validate_config returns warnings for duplicate names and hotkeys
- save_config works on Windows (removes file before rename)
- import_macros de-dupes within imported file
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-robustness/09-01-SUMMARY.md`
</output>
