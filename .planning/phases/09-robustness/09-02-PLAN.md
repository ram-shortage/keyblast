---
phase: 09-robustness
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/config.rs
  - src/tray.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "Hotkey conflicts shown in tray menu (not just console)"
    - "Macro delete works reliably via stable IDs (not names)"
    - "User sees validation warnings in tray submenu"
  artifacts:
    - path: "src/config.rs"
      provides: "MacroDefinition with stable UUID id field"
      contains: "uuid::Uuid"
    - path: "src/tray.rs"
      provides: "Warnings submenu in tray menu"
      contains: "Warnings"
  key_links:
    - from: "src/tray.rs::build_menu"
      to: "ValidationWarning[]"
      via: "warnings parameter"
      pattern: "warnings.*ValidationWarning"
    - from: "src/main.rs delete handler"
      to: "macro.id (UUID)"
      via: "delete_macro_ids map"
      pattern: "delete_macro_ids.*Uuid"
---

<objective>
Add stable UUIDs to macros for reliable delete, surface validation warnings in tray menu.

Purpose: Make delete operations reliable and surface config issues to users visually.
Output: UUID-based delete, warnings submenu in tray.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-robustness/09-01-PLAN.md
@src/config.rs
@src/tray.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add stable UUID to MacroDefinition</name>
  <files>src/config.rs, Cargo.toml</files>
  <action>
Add uuid dependency to Cargo.toml:
```toml
uuid = { version = "1", features = ["v4", "serde"] }
```

Update MacroDefinition in src/config.rs to include a stable ID:
```rust
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct MacroDefinition {
    /// Stable unique identifier for this macro. Auto-generated if not present.
    #[serde(default = "Uuid::new_v4")]
    pub id: Uuid,
    /// Human-readable name for the macro.
    pub name: String,
    /// Hotkey string like "ctrl+shift+k".
    pub hotkey: String,
    /// The text to inject, with {Enter}, {Tab}, etc.
    pub text: String,
    /// Delay between keystrokes in milliseconds. 0 for instant (bulk) typing.
    #[serde(default)]
    pub delay_ms: u64,
    /// Optional group/category for organization. None means "Ungrouped".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
}
```

The `#[serde(default = "Uuid::new_v4")]` ensures:
- Existing configs without `id` get a new UUID on load
- New macros get a UUID automatically
- UUIDs are preserved on save/load

Update any test that creates MacroDefinition to include the id field:
```rust
MacroDefinition {
    id: Uuid::new_v4(),
    name: "...".to_string(),
    // ... rest
}
```
  </action>
  <verify>`cargo build` succeeds, `cargo test` passes</verify>
  <done>MacroDefinition has stable UUID id field that auto-generates on deserialize</done>
</task>

<task type="auto">
  <name>Task 2: Update tray menu to use UUIDs and show warnings</name>
  <files>src/tray.rs</files>
  <action>
Update MenuIds to use UUID instead of String for delete mapping:
```rust
use uuid::Uuid;
use crate::config::ValidationWarning;

pub struct MenuIds {
    pub toggle: muda::MenuId,
    pub edit_config: muda::MenuId,
    pub export_macros: muda::MenuId,
    pub import_macros: muda::MenuId,
    pub auto_start: muda::MenuId,
    pub stop_macro: muda::MenuId,
    pub quit: muda::MenuId,
    /// Map from menu item ID to macro UUID for delete actions
    pub delete_macro_ids: HashMap<muda::MenuId, Uuid>,
}
```

Update build_menu signature to accept warnings:
```rust
pub fn build_menu(
    enabled: bool,
    macros: &[config::MacroDefinition],
    warnings: &[ValidationWarning],
) -> (Menu, MenuIds)
```

In build_menu, after the Macros submenu, add a Warnings submenu if there are warnings:
```rust
// Add Warnings submenu if there are validation warnings
if !warnings.is_empty() {
    let warnings_submenu = Submenu::new(format!("Warnings ({})", warnings.len()), true);

    for warning in warnings {
        let label = warning.to_string();
        let item = MenuItem::new(&label, false, None::<Accelerator>);
        warnings_submenu.append(&item).expect("Failed to add warning item");
    }

    menu.append(&warnings_submenu).expect("Failed to add warnings submenu");
}
```

Update the delete macro mapping to use UUID:
```rust
// Inside the macro loop
let delete_id = delete_item.id().clone();
delete_macro_ids.insert(delete_id, macro_def.id);  // Use .id (UUID) instead of .name
```
  </action>
  <verify>`cargo build` succeeds</verify>
  <done>Tray menu shows warnings submenu and uses UUID for delete mapping</done>
</task>

<task type="auto">
  <name>Task 3: Wire validation and UUID delete in main.rs</name>
  <files>src/main.rs</files>
  <action>
Update the macro map to use UUID:
```rust
/// Map hotkey_id -> macro definition for quick lookup
macros: HashMap<u32, config::MacroDefinition>,
```
(This stays the same - we map hotkey_id to full MacroDefinition which now has UUID)

Update MenuIds initialization to use UUID map:
```rust
delete_macro_ids: std::collections::HashMap::new(),  // Now HashMap<MenuId, Uuid>
```

In the resumed() handler, after loading config:
1. Call validate_config and store warnings
2. Pass warnings to build_menu

```rust
// After: self.config = Some(final_config.clone());
let warnings = config::validate_config(&final_config);
for warning in &warnings {
    eprintln!("Config warning: {}", warning);
}

// Update build_menu call:
let (menu, menu_ids) = tray::build_menu(self.state.enabled, &final_config.macros, &warnings);
```

Store warnings in KeyBlastApp struct:
```rust
struct KeyBlastApp {
    // ... existing fields
    /// Validation warnings from config load
    config_warnings: Vec<config::ValidationWarning>,
}
```

Initialize in new():
```rust
config_warnings: Vec::new(),
```

Update reload_config to re-validate and rebuild menu with warnings:
```rust
fn reload_config(&mut self) {
    match config::load_config() {
        Ok(new_config) => {
            // ... existing unregister/register logic ...

            // Validate and store warnings
            let warnings = config::validate_config(&new_config);
            for warning in &warnings {
                eprintln!("Config warning: {}", warning);
            }
            self.config_warnings = warnings;

            self.config = Some(new_config);
            self.rebuild_menu();
            println!("Config reloaded successfully");
        }
        Err(e) => {
            eprintln!("Failed to reload config: {}", e);
        }
    }
}
```

Update rebuild_menu to pass warnings:
```rust
fn rebuild_menu(&mut self) {
    if let Some(ref config) = self.config {
        let (menu, menu_ids) = tray::build_menu(
            self.state.enabled,
            &config.macros,
            &self.config_warnings,
        );
        // ... rest unchanged
    }
}
```

Update the delete handler in about_to_wait to use UUID:
```rust
// Check if this is a delete macro action
if let Some(macro_id) = self.menu_ids.delete_macro_ids.get(&event.id) {
    let macro_id = *macro_id;  // Copy the UUID
    println!("Deleting macro with ID: {}", macro_id);

    if let Some(ref mut cfg) = self.config {
        // Find and remove the macro by UUID
        let original_len = cfg.macros.len();
        cfg.macros.retain(|m| m.id != macro_id);

        if cfg.macros.len() < original_len {
            // Find and unregister the hotkey
            if let Some(ref mut manager) = self.hotkey_manager {
                let mut id_to_remove = None;
                for (&hotkey_id, binding) in self.macros.iter() {
                    if binding.id == macro_id {
                        if let Some(hotkey) = config::parse_hotkey_string(&binding.hotkey) {
                            let _ = manager.unregister(&hotkey);
                        }
                        id_to_remove = Some(hotkey_id);
                        break;
                    }
                }
                if let Some(id) = id_to_remove {
                    self.macros.remove(&id);
                }
            }

            // Re-validate after deletion
            self.config_warnings = config::validate_config(cfg);

            // Save updated config
            match config::save_config(cfg) {
                Ok(()) => {
                    println!("Macro deleted and config saved");
                }
                Err(e) => {
                    eprintln!("Failed to save config after delete: {}", e);
                }
            }

            self.rebuild_menu();
        }
    }
    continue;
}
```
  </action>
  <verify>`cargo build` succeeds, `cargo run` shows warnings in tray menu</verify>
  <done>Validation runs at load/reload, warnings shown in tray, delete uses UUID</done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds without errors
2. `cargo test` passes all tests
3. Manual test: Create config.toml with duplicate names, run app, see warning in tray menu
4. Manual test: Delete a macro, verify it deletes correctly (by UUID, not name)
5. Inspect config.toml after creating macro to verify UUID is saved
</verification>

<success_criteria>
- Macros have stable UUID that persists across saves
- Delete uses UUID, not name (works with duplicate names)
- Validation warnings appear in tray menu "Warnings (N)" submenu
- Warnings update when config is reloaded
</success_criteria>

<output>
After completion, create `.planning/phases/09-robustness/09-02-SUMMARY.md`
</output>
