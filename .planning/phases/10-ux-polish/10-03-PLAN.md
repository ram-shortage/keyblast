---
phase: 10-ux-polish
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tray.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "User can click menu item to run a macro without using hotkey"
    - "Run Macro submenu shows all macros in flat alphabetized list"
    - "Clicking macro name triggers immediate execution"
  artifacts:
    - path: "src/tray.rs"
      provides: "Run Macro submenu with alphabetized macros"
      contains: "Run Macro"
    - path: "src/tray.rs"
      provides: "run_macro_ids map for click handling"
      contains: "run_macro_ids"
  key_links:
    - from: "src/main.rs"
      to: "run_macro_ids"
      via: "Menu event handler triggers execution"
      pattern: "run_macro_ids\\.get"
    - from: "src/main.rs"
      to: "execution::start_execution"
      via: "Click triggers same execution as hotkey"
      pattern: "start_execution"
---

<objective>
Add "Run Macro" submenu for click-to-run functionality.

Purpose: Users want to run macros by clicking in the menu without remembering hotkeys. Research determined that true search is not possible in native tray menus, so we implement a flat alphabetized list for easy browsing.

Output: "Run Macro" submenu with all macros listed alphabetically. Clicking runs the macro.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-ux-polish/10-RESEARCH.md

@src/tray.rs
@src/main.rs
@src/injection.rs
@src/execution.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Run Macro submenu to tray menu</name>
  <files>src/tray.rs</files>
  <action>
Update MenuIds struct:
- Add `run_macro_ids: HashMap<muda::MenuId, Uuid>` field (maps menu item ID to macro UUID)

In build_menu():
1. After the Enable toggle and Stop Macro items, add a "Run Macro" submenu
2. Create flat list of all macros, sorted alphabetically by name
3. Each macro gets a MenuItem with label format: "{name} ({hotkey})"
4. Store mapping from menu item ID to macro UUID in run_macro_ids
5. Place this submenu BEFORE the existing "Macros" submenu (which is for management/delete)

The resulting menu structure:
```
[x] Enable
Stop Macro
---
Run Macro >
  Macro A (ctrl+a)
  Macro B (ctrl+b)
  ...
Macros >
  [Group Name] >
    Macro Name (hotkey) > Delete
  ...
```

Code pattern:
```rust
// Build Run Macro submenu (flat alphabetized list)
let run_submenu = Submenu::new("Run Macro", true);
let mut sorted_macros: Vec<_> = macros.iter().collect();
sorted_macros.sort_by(|a, b| a.name.to_lowercase().cmp(&b.name.to_lowercase()));

for macro_def in sorted_macros {
    let label = format!("{} ({})", macro_def.name, macro_def.hotkey);
    let item = MenuItem::new(&label, true, None::<Accelerator>);
    let item_id = item.id().clone();
    run_macro_ids.insert(item_id, macro_def.id);
    run_submenu.append(&item).expect("Failed to add run item");
}

menu.append(&run_submenu).expect("Failed to add run submenu");
```
  </action>
  <verify>
`cargo check` passes. Menu structure compiles correctly.
  </verify>
  <done>
"Run Macro" submenu added with flat alphabetized list of all macros.
  </done>
</task>

<task type="auto">
  <name>Task 2: Handle run macro menu events</name>
  <files>src/main.rs</files>
  <action>
In about_to_wait(), in the menu event processing loop, add handler for run_macro_ids:

Check run_macro_ids BEFORE checking delete_macro_ids (both use UUID maps):

```rust
// Check if this is a run macro action
if let Some(macro_id) = self.menu_ids.run_macro_ids.get(&event.id) {
    let macro_id = *macro_id;

    // Find the macro definition by UUID
    let macro_def = self.config.as_ref()
        .and_then(|cfg| cfg.macros.iter().find(|m| m.id == macro_id))
        .cloned();

    if let Some(macro_def) = macro_def {
        // Check if macros are enabled
        if !self.state.enabled {
            println!("Macros disabled, ignoring run request");
            continue;
        }

        // Check if already executing
        if self.active_execution.is_some() {
            println!("Macro already running, ignoring new trigger");
            continue;
        }

        // Trigger execution (same logic as hotkey trigger)
        if let Some(ref mut injector) = self.injector {
            let segments = injection::parse_macro_sequence(&macro_def.text);
            println!("Running macro '{}' from menu", macro_def.name);

            let has_delay = segments.iter().any(|s| matches!(s, injection::MacroSegment::Delay(_)));
            if macro_def.delay_ms == 0 && segments.len() <= 10 && !has_delay {
                // Fast path: short macros with no delay
                match injector.execute_sequence(&segments, 0) {
                    Ok(()) => {
                        println!("Injection complete");
                        self.flash_remaining = 4;
                        self.flash_state = false;
                        self.last_flash_toggle = Some(std::time::Instant::now());
                    }
                    Err(e) => {
                        eprintln!("Injection failed: {}", e);
                    }
                }
            } else {
                // Async path
                let (rx, handle) = execution::start_execution(segments, macro_def.delay_ms);
                self.execution_rx = Some(rx);
                self.active_execution = Some(handle);
                self.execution_prepared = false;
            }
        }
    }
    continue;
}
```

Note: The execution logic is duplicated from the hotkey handler. This is acceptable for now - a future refactor could extract to a shared method.
  </action>
  <verify>
1. `cargo build --release` succeeds
2. Open a text editor
3. Click tray icon -> Run Macro -> [any macro]
4. Text is injected into the editor
5. Icon flashes after completion
  </verify>
  <done>
Clicking macro name in "Run Macro" submenu triggers macro execution with same behavior as hotkey.
  </done>
</task>

</tasks>

<verification>
1. Open tray menu - "Run Macro" submenu appears
2. Submenu shows all macros in alphabetical order
3. Each item shows "Name (hotkey)" format
4. Click any macro - it executes immediately
5. Disabled state is respected (clicking while disabled does nothing)
6. Running state is respected (can't run while another macro is executing)
</verification>

<success_criteria>
- UX-01 satisfied: Flat alphabetized submenu for macro browsing
- UX-02 satisfied: Click-to-run works as alternative to hotkeys
- Same execution behavior as hotkey trigger (flash, async for long macros)
</success_criteria>

<output>
After completion, create `.planning/phases/10-ux-polish/10-03-SUMMARY.md`
</output>
