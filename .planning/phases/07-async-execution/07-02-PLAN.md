---
phase: 07-async-execution
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/main.rs
  - src/tray.rs
autonomous: true

must_haves:
  truths:
    - "Long macros don't freeze the tray menu"
    - "User can stop a running macro mid-execution"
    - "Macro execution happens in background thread"
    - "Icon flash occurs after macro completes (not at start)"
  artifacts:
    - path: "src/main.rs"
      provides: "Integrated async execution with stop hotkey"
      contains: "active_execution"
    - path: "src/tray.rs"
      provides: "Stop Macro menu item"
      contains: "stop_macro"
  key_links:
    - from: "src/main.rs"
      to: "src/execution.rs"
      via: "start_execution call and command processing"
      pattern: "execution::start_execution"
    - from: "src/main.rs"
      to: "about_to_wait"
      via: "command receiver processing"
      pattern: "execution_rx.*try_recv"
---

<objective>
Wire async execution into KeyBlastApp: process commands in event loop, add stop hotkey, add stop menu item.

Purpose: Complete the async execution feature by integrating the execution module into the application, making long macros non-blocking and stoppable.

Output: Fully functional async macro execution with user-accessible stop capability via both hotkey and menu.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-async-execution/07-RESEARCH.md
@.planning/phases/07-async-execution/07-01-SUMMARY.md

Reference files:
@src/main.rs (KeyBlastApp struct, user_event, about_to_wait)
@src/tray.rs (MenuIds, build_menu)
@src/execution.rs (from Plan 07-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add execution state to KeyBlastApp and process commands</name>
  <files>src/main.rs</files>
  <action>
Modify KeyBlastApp to support async execution:

1. **Add new fields to KeyBlastApp struct:**
```rust
/// Active execution handle (if macro running)
active_execution: Option<execution::ExecutionHandle>,
/// Receiver for execution commands from worker thread
execution_rx: Option<crossbeam_channel::Receiver<execution::ExecutionCommand>>,
/// Whether we've prepared the injector for this execution run
execution_prepared: bool,
```

2. **Initialize in new():**
```rust
active_execution: None,
execution_rx: None,
execution_prepared: false,
```

3. **Modify about_to_wait() to process execution commands:**
Before the config change check, add:
```rust
// Process async execution commands (non-blocking)
if let Some(ref rx) = self.execution_rx {
    while let Ok(cmd) = rx.try_recv() {
        match cmd {
            execution::ExecutionCommand::Inject(segment) => {
                if let Some(ref mut injector) = self.injector {
                    // Prepare injector once at start of execution
                    if !self.execution_prepared {
                        let _ = injector.prepare_for_injection();
                        self.execution_prepared = true;
                    }
                    // Execute segment on main thread (safe for macOS TIS/TSM)
                    let _ = injector.execute_single_segment(&segment);
                }
            }
            execution::ExecutionCommand::Complete => {
                println!("Macro execution complete");
                self.active_execution = None;
                self.execution_rx = None;
                self.execution_prepared = false;
                // Trigger icon flash AFTER completion
                self.flash_remaining = 4;
                self.flash_state = false;
                self.last_flash_toggle = Some(std::time::Instant::now());
            }
            execution::ExecutionCommand::Cancelled => {
                println!("Macro execution cancelled");
                self.active_execution = None;
                self.execution_rx = None;
                self.execution_prepared = false;
                // No flash on cancel - user knows they cancelled
            }
        }
    }
}
```

4. **Modify user_event() hotkey handler to use async execution:**
Replace the synchronous injection code with:
```rust
// Check if already executing
if self.active_execution.is_some() {
    println!("Macro already running, ignoring new trigger");
    return;
}

// Inject the macro text using async execution
if let Some(ref mut injector) = self.injector {
    let segments = injection::parse_macro_sequence(&macro_def.text);
    let mode_name = if macro_def.delay_ms == 0 { "instant" } else { "slow" };
    println!("Injecting macro '{}' ({}): {}", macro_def.name, mode_name, macro_def.text);

    if macro_def.delay_ms == 0 && segments.len() <= 10 {
        // Fast path: short macros with no delay run synchronously
        // This avoids overhead for simple text expansion
        match injector.execute_sequence(&segments, 0) {
            Ok(()) => {
                println!("Injection complete");
                self.flash_remaining = 4;
                self.flash_state = false;
                self.last_flash_toggle = Some(std::time::Instant::now());
            }
            Err(e) => {
                eprintln!("Injection failed: {}", e);
            }
        }
    } else {
        // Async path: spawn worker thread for long or delayed macros
        let (rx, handle) = execution::start_execution(segments, macro_def.delay_ms);
        self.execution_rx = Some(rx);
        self.active_execution = Some(handle);
        self.execution_prepared = false;
        // Flash happens when Complete command received
    }
}
```

5. **Add import at top:**
```rust
use crossbeam_channel;
```
  </action>
  <verify>
`cargo build` passes, app launches without errors
  </verify>
  <done>
KeyBlastApp has execution state fields, about_to_wait processes commands, hotkey handler uses async for long/delayed macros
  </done>
</task>

<task type="auto">
  <name>Task 2: Add stop hotkey and menu item</name>
  <files>src/main.rs, src/tray.rs</files>
  <action>
**In src/tray.rs:**

1. **Add stop_macro field to MenuIds:**
```rust
pub struct MenuIds {
    pub toggle: muda::MenuId,
    pub edit_config: muda::MenuId,
    pub export_macros: muda::MenuId,
    pub import_macros: muda::MenuId,
    pub auto_start: muda::MenuId,
    pub stop_macro: muda::MenuId,  // NEW
    pub quit: muda::MenuId,
    pub delete_macro_ids: std::collections::HashMap<muda::MenuId, String>,
}
```

2. **In build_menu(), add Stop Macro item after toggle:**
After the toggle checkbox and before the separator, add:
```rust
// Stop Macro item (initially disabled)
let stop_item = muda::MenuItem::new("Stop Macro", false, None::<muda::accelerator::Accelerator>);
let stop_id = stop_item.id().clone();
menu.append(&stop_item).unwrap();
```
Update MenuIds return to include `stop_macro: stop_id`.

**In src/main.rs:**

3. **Add stop hotkey ID field to KeyBlastApp:**
```rust
/// ID of the stop macro hotkey (Ctrl+Escape / Cmd+Escape)
stop_hotkey_id: Option<u32>,
```
Initialize as `None` in new().

4. **Register stop hotkey in resumed():**
After registering macro hotkeys, add:
```rust
// Register stop hotkey (Ctrl+Escape on all platforms)
use global_hotkey::{hotkey::{HotKey, Code, Modifiers}};
let stop_hotkey = HotKey::new(Some(Modifiers::CONTROL), Code::Escape);
if let Some(ref mut manager) = self.hotkey_manager {
    match manager.register_raw(stop_hotkey) {
        Ok(()) => {
            self.stop_hotkey_id = Some(stop_hotkey.id());
            println!("Stop hotkey registered: Ctrl+Escape");
        }
        Err(e) => {
            eprintln!("Failed to register stop hotkey: {}", e);
        }
    }
}
```

5. **Add register_raw method to HotkeyManager in src/hotkey.rs:**
```rust
/// Register a hotkey without a macro name (for system hotkeys like stop)
pub fn register_raw(&mut self, hotkey: HotKey) -> Result<(), HotkeyError> {
    self.manager.register(hotkey)?;
    Ok(())
}
```

6. **Handle stop hotkey in user_event():**
At the start of the HotKey match arm, before looking up the macro:
```rust
// Check for stop hotkey
if Some(hotkey_event.id) == self.stop_hotkey_id {
    if let Some(ref handle) = self.active_execution {
        handle.stop();
        println!("Stop hotkey pressed - macro will stop");
    }
    return;
}
```

7. **Handle stop menu item in about_to_wait():**
After the delete macro check, add:
```rust
} else if event.id == self.menu_ids.stop_macro {
    if let Some(ref handle) = self.active_execution {
        handle.stop();
        println!("Stop menu clicked - macro will stop");
    }
}
```

8. **Update Stop Macro menu item enabled state:**
After processing execution commands in about_to_wait(), add logic to enable/disable the Stop Macro menu item based on whether execution is active. Use the menu iteration pattern already in the code:
```rust
// Update Stop Macro menu item enabled state
let is_running = self.active_execution.is_some();
for item in self.menu.items() {
    if let muda::MenuItemKind::Normal(normal_item) = item {
        if normal_item.id() == &self.menu_ids.stop_macro {
            normal_item.set_enabled(is_running);
            break;
        }
    }
}
```
  </action>
  <verify>
`cargo build` passes, stop hotkey Ctrl+Escape registered, Stop Macro menu item visible
  </verify>
  <done>
Stop hotkey (Ctrl+Escape) registered and handled, Stop Macro menu item added and toggles enabled state based on execution
  </done>
</task>

<task type="auto">
  <name>Task 3: End-to-end testing and cleanup</name>
  <files>src/main.rs</files>
  <action>
1. **Test async execution manually:**
   - Create a macro with delay_ms > 0 (e.g., 100ms)
   - Trigger it and verify tray menu remains responsive
   - Try triggering another macro while one is running (should be ignored)
   - Press Ctrl+Escape mid-execution (should stop)

2. **Clean up thread on app exit:**
In the quit handler, ensure execution thread is joined if running:
```rust
} else if event.id == self.menu_ids.quit {
    // Clean up active execution if running
    if let Some(handle) = self.active_execution.take() {
        handle.stop();
        handle.join();
    }
    println!("KeyBlast shutting down.");
    process::exit(0);
}
```

3. **Verify no compiler warnings:**
Run `cargo clippy` if available, or `cargo build` and check for warnings.
Fix any unused import warnings or dead code warnings.

4. **Update the example macro comment if needed:**
The default macro created on first run has delay_ms: 0, which is fine - it will use the fast path.
  </action>
  <verify>
`cargo build` with no warnings, manual testing confirms:
- Long delayed macros don't freeze menu
- Ctrl+Escape stops execution
- Menu Stop item enables/disables correctly
  </verify>
  <done>
Async execution fully working: non-blocking, stoppable via hotkey and menu, thread cleanup on exit
  </done>
</task>

</tasks>

<verification>
- `cargo build` completes with no warnings
- Long macros (delay_ms > 0) execute without freezing tray menu
- Ctrl+Escape stops a running macro
- Stop Macro menu item enables when macro running, disabled otherwise
- Icon flash occurs after macro completes (not at trigger)
- Thread properly cleaned up on quit
</verification>

<success_criteria>
1. ASYNC-01: Macro execution runs off event loop thread - verified by tray menu responsiveness during delayed macros
2. ASYNC-02: User can stop running macro - verified by Ctrl+Escape and Stop Macro menu item
3. ASYNC-03: Tray menu stays responsive - verified by being able to open menu during long macro
</success_criteria>

<output>
After completion, create `.planning/phases/07-async-execution/07-02-SUMMARY.md`
</output>
