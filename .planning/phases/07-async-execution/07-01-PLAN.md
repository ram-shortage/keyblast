---
phase: 07-async-execution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/execution.rs
  - src/injection.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "Worker thread handles timing/delays without blocking main thread"
    - "Commands flow from worker to main thread via channel"
    - "Cancellation flag stops execution between segments"
  artifacts:
    - path: "src/execution.rs"
      provides: "Async execution module with worker thread and commands"
      exports: ["ExecutionCommand", "ExecutionHandle", "start_execution"]
    - path: "src/injection.rs"
      provides: "Single-segment execution method"
      exports: ["execute_single_segment"]
  key_links:
    - from: "src/execution.rs"
      to: "crossbeam-channel"
      via: "unbounded channel for commands"
      pattern: "crossbeam_channel::"
    - from: "src/execution.rs"
      to: "std::sync::atomic"
      via: "AtomicBool for stop flag"
      pattern: "AtomicBool"
---

<objective>
Create the async execution infrastructure: worker thread, command channel, execution handle, and stop flag.

Purpose: Enable non-blocking macro execution with cancellation support. This is the foundation that Plan 07-02 will wire into the application.

Output: `src/execution.rs` module with `start_execution()` function that spawns a worker thread and returns a command receiver + execution handle.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-async-execution/07-RESEARCH.md

Reference files:
@src/injection.rs (MacroSegment type, parse_macro_sequence)
@src/main.rs (current synchronous execution in user_event)
@Cargo.toml (crossbeam-channel already present)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create execution module with worker thread infrastructure</name>
  <files>src/execution.rs</files>
  <action>
Create new module `src/execution.rs` with:

1. **ExecutionCommand enum:**
   - `Inject(MacroSegment)` - tells main thread to execute one segment
   - `Complete` - execution finished successfully
   - `Cancelled` - execution was stopped by user

2. **ExecutionHandle struct:**
   - `stop_flag: Arc<AtomicBool>` - set to true to request cancellation
   - `thread: Option<JoinHandle<()>>` - for cleanup on app exit
   - Methods: `stop()`, `is_running()`, `join()`

3. **start_execution function:**
   ```rust
   pub fn start_execution(
       segments: Vec<MacroSegment>,
       delay_ms: u64,
   ) -> (Receiver<ExecutionCommand>, ExecutionHandle)
   ```
   - Creates unbounded crossbeam channel
   - Creates Arc<AtomicBool> stop flag
   - Spawns worker thread that:
     - Iterates segments, checking stop flag before each
     - Sends `Inject(segment)` command to main thread
     - Sleeps for delay_ms between segments (if > 0)
     - During sleep, checks stop flag every 50ms to respond quickly
     - Sends `Complete` or `Cancelled` at end
   - Returns receiver and handle

4. **Worker thread function** (private):
   - Check stop flag before each segment
   - Send segment via channel
   - For delays: sleep in 50ms increments, checking stop flag each time
   - Handle channel send errors gracefully (receiver dropped)

Use `crossbeam_channel::unbounded()` for the channel (already in Cargo.toml).
Use `std::sync::atomic::{AtomicBool, Ordering}` and `std::sync::Arc` for the stop flag.
Use `Ordering::Relaxed` for the stop flag - sufficient for this use case.

Import MacroSegment from crate::injection.
  </action>
  <verify>
`cargo check` passes with new module (add `mod execution;` to main.rs temporarily for check)
  </verify>
  <done>
src/execution.rs exists with ExecutionCommand, ExecutionHandle, and start_execution function that compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Add execute_single_segment method to KeystrokeInjector</name>
  <files>src/injection.rs</files>
  <action>
Add a new method to `KeystrokeInjector` that executes a single segment without the modifier release and sleep logic (those will be handled by the execution module):

```rust
/// Execute a single macro segment.
///
/// Unlike execute_sequence, this does NOT:
/// - Release modifiers (caller must handle once at start)
/// - Wait between segments (caller handles timing)
///
/// Used by async execution where timing is managed by worker thread.
pub fn execute_single_segment(&mut self, segment: &MacroSegment) -> Result<(), InjectionError> {
    match segment {
        MacroSegment::Text(text) => {
            self.enigo.text(text)?;
        }
        MacroSegment::SpecialKey(key) => {
            self.enigo.key(*key, Direction::Click)?;
        }
    }
    Ok(())
}
```

Also add a public method to release modifiers that can be called once at execution start:
```rust
/// Release modifiers and wait for them to take effect.
/// Call once at the start of async execution.
pub fn prepare_for_injection(&mut self) -> Result<(), InjectionError> {
    self.release_modifiers()?;
    std::thread::sleep(std::time::Duration::from_millis(50));
    Ok(())
}
```

This allows the async execution module to:
1. Call prepare_for_injection() once when starting
2. Call execute_single_segment() for each segment received from worker
  </action>
  <verify>
`cargo check` passes, existing tests still pass with `cargo test`
  </verify>
  <done>
KeystrokeInjector has execute_single_segment() and prepare_for_injection() methods
  </done>
</task>

<task type="auto">
  <name>Task 3: Register execution module and verify compilation</name>
  <files>src/main.rs</files>
  <action>
Add the module declaration near the top of main.rs with other module declarations:

```rust
mod execution;
```

Run full build to verify everything compiles together. The execution module won't be used yet (that's Plan 07-02), but it must compile cleanly with the rest of the codebase.
  </action>
  <verify>
`cargo build` succeeds with no warnings about unused code (allow dead_code if needed for now)
  </verify>
  <done>
Module registered, full build passes, ready for integration in Plan 07-02
  </done>
</task>

</tasks>

<verification>
- `cargo build` completes successfully
- `cargo test` passes (existing injection tests)
- `src/execution.rs` contains ExecutionCommand, ExecutionHandle, start_execution
- `src/injection.rs` has new methods: execute_single_segment, prepare_for_injection
- No warnings about missing imports or type mismatches
</verification>

<success_criteria>
1. New execution module compiles and exports the async execution API
2. Injection module has single-segment execution method
3. Build passes with all modules integrated
4. Ready for Plan 07-02 to wire execution into event loop
</success_criteria>

<output>
After completion, create `.planning/phases/07-async-execution/07-01-SUMMARY.md`
</output>
